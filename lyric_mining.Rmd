---
title: "Mining Lyrics"
output: html_notebook
---

```{r}
library(tidyverse)
library(magrittr)
library(genius)
library(kernlab) 
library(caret) 
library(tm) 
library(splitstackshape)
library(e1071)
library(httr)		# Library for scraping web data
library(jsonlite)	# Library for reading JSON data
```
```{r Functions for scraping data}
# Retrieving an artist's MusicBrainz ID from last.fm
get_artist_mbid <- function(name_artist){

  url <- "http://ws.audioscrobbler.com/2.0/?"
  method <- "method=artist.getInfo"
  parameter <- paste0("artist=", name_artist)
  api_key <- "api_key=bd357ecfcaa0085f4948c273729f44f4"
  format <- "format=json"
  qty_albums <- "limit=1"
  rest_request <- paste0(url, paste(method, parameter, api_key, format, sep = "&"))
  
  json <- GET( rest_request ) #, use_proxy("172.16.16.62", 8080))	# Executing request
  json_text <- content(json, as="text", encoding = "UTF-8")				# Get JSON text data
  ls_artist <- fromJSON(json_text)				# loading text data in a list

  return(ls_artist[1]$artist$mbid)
}
``` 
```{r}
# Retrieving an artist's studio albums from MusicBrainz
get_artist_studio_albums <- function(artist_mbid){
  
  url <- "http://musicbrainz.org/ws/2/artist/"
  filter <- "?inc=release-groups"
  format <- "format=json"
  rest_request <- paste0(url, artist_mbid, filter, "&", format)
  
  json <- GET( rest_request ) # , use_proxy("172.16.16.62", 8080))	# Executing request
  json_text <- content(json, as="text", encoding = "UTF-8")				# Get JSON text data
  ls_albums <- fromJSON(json_text)				# loading text data in a list
  
  ls_album_types <- ls_albums$`release-groups`$`secondary-types`
  ls_album_types <- lapply(ls_album_types, function(x) ifelse(is.null(x), NA, x))
  
  df_albums <- tibble(artist = rep(ls_albums$`sort-name`, nrow(ls_albums$`release-groups`)),
                      album = ls_albums$`release-groups`$title,
                      date_appearance = ls_albums$`release-groups`$`first-release-date`,
                      album_type = unlist(ls_album_types))
  
  df_albums %<>%
    filter(is.na(album_type)) %>% 
    mutate(year_release = str_sub(date_appearance, 1, 4)) %>% 
    select(artist, album, year_release)
  row.names(df_albums) <- NULL
  
  return(df_albums)
}
``` 
```{r}
# Retrieving an artist's studio albums from last.fm
get_artist_albums <- function(name_artist){

  url <- "http://ws.audioscrobbler.com/2.0/?"
  method <- "method=artist.getTopAlbums"
  parameter <- paste0("artist=", name_artist)
  api_key <- "api_key=bd357ecfcaa0085f4948c273729f44f4"
  format <- "format=json"
  qty_albums <- "limit=150"
  rest_request <- paste0(url, paste(method, parameter, api_key, format, delimiter = "&"))
  
  # Executing REST request and getting josn text data
  json <- GET( rest_request ) #, use_proxy("172.16.16.62", 8080))	# Executing request
  json_text <- content(json, as = "text")				# Get JSON text data
  ls_albums <- fromJSON(json_text)				# loading text data in a list

  df_albums <- ls_albums$topalbums$album
  df_albums <- as.tibble(cbind(artist = rep(name_artist, nrow(df_albums)),
                               album = df_albums$name))
  return(df_albums)
}

```

```{r}
vec_artists <- c("Tindersticks", "Tom Waits", "Nick Cave and The Bad Seeds", "Vanilla Ice", "The National", "Metallica")

df_artists <- tibble(artist = vec_artists,
                     artist_mbid = sapply(vec_artists, get_artist_mbid))
rm(vec_artists)
```
```{r}
file_albums <- "artists_albums.csv"

if(file.exists(file_albums)){
  df_albums <- read_csv2(file_albums)
} else {
  df_albums <- tibble(artist = character(0),
                      album = character(0),
                      year_release = character(0))
}

artists_search <- df_artists$artist_mbid[!df_artists %in% df_albums$artist]
```
```{r}
for(artist_mbid in artists_search){

  df_artist_albums <- tibble(artist = character(0), album = character(0), year_release = character(0))
  
  attempt <- 0
  while( (nrow(df_artist_albums) == 0 | is.null(df_artist_albums))
         && attempt <= 99 ) {
    attempt <- attempt + 1
    try(
      df_artist_albums <- get_artist_studio_albums(artist_mbid)
    )
    # Sys.sleep(1)
  }
  
  if(nrow(df_artist_albums) > 0) {
    # Rename artist back to original form
    name_artist <- df_artists$artist[df_artists$artist_mbid == artist_mbid]
    df_artist_albums %<>%
      mutate(artist = name_artist)
  
    df_albums <- rbind(df_albums, df_artist_albums)  
  
    print(paste0("Added ", name_artist, " - ", nrow(df_artist_albums), " albums"))
  }
    
}
rm(df_artist_albums)
write_csv2(df_albums, "artists_albums.csv")
```

```{r Loading data}
# Read albums and pre-processed lyrics
file_lyrics <- "df_lyrics.RDS"
if(file.exists(file_lyrics)){
  df_lyrics <- read_rds(file_lyrics) 
} else {
  df_lyrics <- tibble(artist = character(0), album = character(0))
}

# See whether new albumn lyrics should be retrieved
df_lyrics_new <- df_albums %>% 
  anti_join(df_lyrics, by = c("artist", "album")) %>% 
  add_genius(artist, album)

# Add new album lyrics
if(nrow(df_lyrics) != 0){
  df_lyrics <- rbind(df_lyrics, df_lyrics_new)
} else {
  df_lyrics <- df_lyrics_new
}

# Write found lyrics
write_rds(df_lyrics, file_lyrics, compress = "gz")

# Albums without lyrics
df_albums %>% 
  anti_join(df_lyrics, by = c("artist", "album")) %>% 
  knitr::kable()
```

```{r}
# Create row per track, combining lyrics in one text field
df_lyric_dox <- df_lyrics %>% 
  filter(!is.na(lyric)) %>% 
  group_by(artist, album, year_appearance, track_title, track_n) %>% 
  summarise(lyric = paste0(lyric, collapse = " ")) %>% 
  ungroup() %>% 
  mutate(doc_id = row_number()) %>% 
  dplyr::select(doc_id, text = lyric, everything())

# Make factor of artists for modelling
levels_artists <- unique(df_lyric_dox$artist)
df_lyric_dox$artist <- factor(df_lyric_dox$artist, levels = levels_artists)

# Convert df_source to a corpus: df_corpus
df_source <- VectorSource(df_lyric_dox$text)
corpus_lyrics <- Corpus(df_source)

# Clean corpus
corpus_lyrics %<>% 
  tm_map(removeWords, c("-", "...", "NA", "character")) %>% 
  tm_map(content_transformer(tolower)) %>% 
  tm_map(content_transformer(removeNumbers)) %>% 
  tm_map(content_transformer(removePunctuation)) %>% 
  tm_map(removeWords, stopwords("english")) %>% 
  tm_map(content_transformer(stripWhitespace))

```
```{r}
# Create document term and term document matrices
dtm_lyrics <- DocumentTermMatrix(corpus_lyrics)
tdm_lyrics <- TermDocumentMatrix(corpus_lyrics)
```
```{r}
# Convert TDM to matrix
mat_lyrics <- as.matrix(tdm_lyrics)
# Sum rows and frequency data frame
lyrics_term_freq <- rowSums(mat_lyrics)
# Sort term_frequency in descending order
lyrics_term_freq <- sort(lyrics_term_freq, decreasing = TRUE)
barplot(lyrics_term_freq[1:20], col = "steel blue", las = 2)
```
```{r}
library(wordcloud)
lyrics_word_freq <- data.frame(term = names(lyrics_term_freq),
  num = lyrics_term_freq)
# Create a wordcloud for the values in word_freqs
wordcloud(lyrics_word_freq$term, lyrics_word_freq$num, max.words = 50, colors = "red")
```


```{r Setting up training and test set}
set.seed(42)
qty_train <- round(length(corpus_lyrics) * .8, 0)
idx_train <- sample(1:length(corpus_lyrics), qty_train)
idx_test <- c(1:length(corpus_lyrics))[!c(1:length(corpus_lyrics)) %in% idx_train]

corpus_train <- corpus_lyrics[idx_train]
corpus_test <- corpus_lyrics[idx_test]
```

```{r Creating document term matrices}
dtm_train <- as.matrix(DocumentTermMatrix(corpus_train, control=list(wordLengths=c(1,Inf))))
dtm_test <- as.matrix(DocumentTermMatrix(corpus_test, control=list(wordLengths=c(1,Inf))))
```

```{r Conforming DTMs}
df_train <- data.frame(dtm_train[,intersect(colnames(dtm_train), colnames(dtm_test))])
df_test <- data.frame(dtm_test[,intersect(colnames(dtm_test), colnames(dtm_train))])
```

```{r}
df_train$corpus <- df_lyric_dox$artist[idx_train]
df_test$corpus <- df_lyric_dox$artist[idx_test]
```

```{r Create model}
fit_model <- ksvm(corpus ~ ., data = df_train, kernel = "rbfdot")
df_pred <- predict(fit_artists, df_test, type = "prob")

```
```{r}
fit_artists <- train(corpus ~ ., data = df_train, method = "svmLinear3")
```

```{r Predict}
df_pred <- predict(fit_artists, df_test) #, type = "prob")
```

```{r}
matrix_confusion <- confusionMatrix(df_pred, df_test$corpus)
matrix_confusion
```

```{r}
df_accuracy <- cbind(df_lyric_dox[idx_test, ], prediction = df_pred)
df_accuracy$accuracy <- if_else(df_accuracy$prediction == df_accuracy$artist, 1, 0)
```
```{r}
library(performanceEstimation)
classificationMetrics(df_accuracy$artist, df_accuracy$prediction)
```
